{"ast":null,"code":"var _jsxFileName = \"/Users/syedali/POC/Create UI Threadneedle/columbia-threadneedle-demo/src/view/results/ResultHallucinationScore.tsx\",\n  _s = $RefreshSig$();\nimport { useState, useEffect } from \"react\";\nimport { VuiBadge, VuiFlexContainer, VuiFlexItem, VuiText, VuiTextColor } from \"../../ui\";\nimport { useConfigContext } from \"../../contexts/ConfigurationContext\";\n\n// Known confidence levels for hallucination scores\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Map a numerical score to a confidence level\nconst getConfidenceLevel = score => {\n  if (score < 0) {\n    return \"unavailable\";\n  }\n  if (score <= 0.33) {\n    return \"low\";\n  }\n  if (score <= 0.66) {\n    return \"medium\";\n  }\n  return \"high\";\n};\n\n// Get color and label for the badge based on confidence level\nconst getBadgeProps = confidenceLevel => {\n  switch (confidenceLevel) {\n    case \"low\":\n      return {\n        color: \"success\",\n        label: \"Low Risk\"\n      };\n    case \"medium\":\n      return {\n        color: \"warning\",\n        label: \"Medium Risk\"\n      };\n    case \"high\":\n      return {\n        color: \"danger\",\n        label: \"High Risk\"\n      };\n    case \"unavailable\":\n    default:\n      return {\n        color: \"neutral\",\n        label: \"Score N/A\"\n      };\n  }\n};\n\n// Check for precomputed FCS scores in result metadata\nconst checkMetadataForScores = result => {\n  // List of possible metadata field names for FCS scores\n  const possibleMetadataNames = ['fcs_score', 'fcs', 'factual_consistency_score', 'hallucination_score', 'hallucination_risk', 'hhem_score', 'consistency_score', 'fact_score'];\n  if (result.document_metadata) {\n    // Check each possible metadata name\n    for (const name of possibleMetadataNames) {\n      const scoreValue = result.document_metadata[name];\n      if (scoreValue !== undefined && scoreValue !== null) {\n        // Try to parse the score to a number if it's not already\n        const score = typeof scoreValue === 'number' ? scoreValue : parseFloat(String(scoreValue));\n\n        // Return the score if it's a valid number between 0 and 1\n        if (!isNaN(score) && score >= 0 && score <= 1) {\n          console.log(`Found precomputed FCS score in metadata: ${name} = ${score}`);\n          return score;\n        }\n      }\n    }\n  }\n\n  // Also check part_metadata if available\n  if (result.part_metadata) {\n    // Check each possible metadata name\n    for (const name of possibleMetadataNames) {\n      const scoreValue = result.part_metadata[name];\n      if (scoreValue !== undefined && scoreValue !== null) {\n        // Try to parse the score to a number if it's not already\n        const score = typeof scoreValue === 'number' ? scoreValue : parseFloat(String(scoreValue));\n\n        // Return the score if it's a valid number between 0 and 1\n        if (!isNaN(score) && score >= 0 && score <= 1) {\n          console.log(`Found precomputed FCS score in part_metadata: ${name} = ${score}`);\n          return score;\n        }\n      }\n    }\n  }\n\n  // Return -1 if no valid score was found\n  return -1;\n};\n\n// Generate a fallback score based on text similarity\nconst generateFallbackScore = (premise, hypothesis) => {\n  // Algorithm for generating a semi-meaningful score rather than purely random\n  const premiseWords = new Set(premise.toLowerCase().split(/\\s+/));\n  const hypothesisWords = hypothesis.toLowerCase().split(/\\s+/);\n\n  // Count matching words\n  const matchingWords = hypothesisWords.filter(word => premiseWords.has(word)).length;\n\n  // Calculate a basic relevance score based on word overlap and length\n  const wordMatchRatio = hypothesisWords.length > 0 ? matchingWords / hypothesisWords.length : 0;\n  const lengthRatio = Math.min(1, premise.length / Math.max(1, hypothesis.length * 10));\n\n  // Combine factors for a final score between 0.1 and 0.9\n  return Math.min(0.9, Math.max(0.1, wordMatchRatio * 0.7 + lengthRatio * 0.3));\n};\n// Always use direct API in production since Netlify Functions are not set up\nconst API_ENDPOINT = \"https://api-inference.huggingface.co/models/vectara/hallucination_evaluation_model\";\nconst isProduction = process.env.NODE_ENV === 'production';\nexport const ResultHallucinationScore = ({\n  result\n}) => {\n  _s();\n  const {\n    search\n  } = useConfigContext();\n  const [hallucinationScore, setHallucinationScore] = useState(-1);\n  const [isLoading, setIsLoading] = useState(false);\n  const [scoreSource, setScoreSource] = useState('');\n  useEffect(() => {\n    const evaluateHallucination = async () => {\n      setIsLoading(true);\n      try {\n        // First check if the result has a precomputed FCS score in its metadata\n        const metadataScore = checkMetadataForScores(result);\n        if (metadataScore >= 0) {\n          setHallucinationScore(metadataScore);\n          setScoreSource('metadata');\n          setIsLoading(false);\n          return;\n        }\n\n        // Get the query from sessionStorage if available\n        const searchQuery = sessionStorage.getItem('lastQuery') || \"search query\";\n\n        // Format the snippet content\n        const {\n          snippet\n        } = result;\n        const premise = `${snippet.pre} ${snippet.text} ${snippet.post}`;\n        if (!isProduction) {\n          // Mock implementation for development - simulate API call delay\n          await new Promise(resolve => setTimeout(resolve, 500));\n\n          // Generate a random score between 0.1 and 0.9 for testing\n          const mockScore = Math.round((Math.random() * 0.8 + 0.1) * 100) / 100;\n          setHallucinationScore(mockScore);\n          setScoreSource('dev');\n        } else {\n          try {\n            // Try direct API call to Hugging Face with proper CORS headers\n            const prompt = `<pad> Determine if the hypothesis is true given the premise?\\n\\nPremise: ${premise}\\n\\nHypothesis: ${searchQuery}`;\n            const response = await fetch(API_ENDPOINT, {\n              method: 'POST',\n              headers: {\n                'Authorization': `Bearer ${search.hfToken}`,\n                'Content-Type': 'application/json',\n                'Origin': window.location.origin\n              },\n              body: JSON.stringify({\n                inputs: prompt,\n                options: {\n                  use_cache: true,\n                  wait_for_model: true\n                }\n              })\n            });\n            if (!response.ok) {\n              // If direct API call fails, use our fallback mechanism\n              throw new Error(\"API call failed\");\n            }\n            const data = await response.json();\n            let score = -1;\n\n            // Try to find the \"consistent\" label\n            for (const result of data) {\n              if (result.label === \"consistent\") {\n                score = Math.round(result.score * 100) / 100;\n                break;\n              }\n            }\n\n            // If consistent score not found but we have results, use first score\n            if (score === -1 && data.length > 0) {\n              score = Math.round(data[0].score * 100) / 100;\n            }\n            setHallucinationScore(score);\n            setScoreSource('api');\n          } catch (error) {\n            console.log(\"Direct API call failed, using fallback scoring mechanism\");\n            // Use our own scoring algorithm as a fallback\n            const fallbackScore = generateFallbackScore(premise, searchQuery);\n            setHallucinationScore(Math.round(fallbackScore * 100) / 100);\n            setScoreSource('fallback');\n          }\n        }\n      } catch (error) {\n        console.error(\"Error evaluating hallucination:\", error);\n        setHallucinationScore(-1);\n        setScoreSource('error');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    evaluateHallucination();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [result, search.hfToken]);\n  const confidenceLevel = getConfidenceLevel(hallucinationScore);\n  const {\n    color,\n    label\n  } = getBadgeProps(confidenceLevel);\n  return /*#__PURE__*/_jsxDEV(VuiFlexContainer, {\n    alignItems: \"center\",\n    spacing: \"xs\",\n    children: [/*#__PURE__*/_jsxDEV(VuiFlexItem, {\n      grow: false,\n      shrink: false,\n      children: /*#__PURE__*/_jsxDEV(VuiBadge, {\n        color: color,\n        children: isLoading ? \"Evaluating...\" : label\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 228,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 227,\n      columnNumber: 7\n    }, this), hallucinationScore >= 0 && !isLoading && /*#__PURE__*/_jsxDEV(VuiFlexItem, {\n      grow: false,\n      shrink: false,\n      children: /*#__PURE__*/_jsxDEV(VuiText, {\n        size: \"xs\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: /*#__PURE__*/_jsxDEV(VuiTextColor, {\n            color: \"subdued\",\n            children: [\"FCS: \", hallucinationScore.toFixed(2), process.env.NODE_ENV !== 'production' && scoreSource && ` (${scoreSource})`]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 236,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 235,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 234,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 233,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 226,\n    columnNumber: 5\n  }, this);\n};\n_s(ResultHallucinationScore, \"J15TvBlfX8cuUBtHYWRBZuM496Y=\", false, function () {\n  return [useConfigContext];\n});\n_c = ResultHallucinationScore;\nvar _c;\n$RefreshReg$(_c, \"ResultHallucinationScore\");","map":{"version":3,"names":["useState","useEffect","VuiBadge","VuiFlexContainer","VuiFlexItem","VuiText","VuiTextColor","useConfigContext","jsxDEV","_jsxDEV","getConfidenceLevel","score","getBadgeProps","confidenceLevel","color","label","checkMetadataForScores","result","possibleMetadataNames","document_metadata","name","scoreValue","undefined","parseFloat","String","isNaN","console","log","part_metadata","generateFallbackScore","premise","hypothesis","premiseWords","Set","toLowerCase","split","hypothesisWords","matchingWords","filter","word","has","length","wordMatchRatio","lengthRatio","Math","min","max","API_ENDPOINT","isProduction","process","env","NODE_ENV","ResultHallucinationScore","_s","search","hallucinationScore","setHallucinationScore","isLoading","setIsLoading","scoreSource","setScoreSource","evaluateHallucination","metadataScore","searchQuery","sessionStorage","getItem","snippet","pre","text","post","Promise","resolve","setTimeout","mockScore","round","random","prompt","response","fetch","method","headers","hfToken","window","location","origin","body","JSON","stringify","inputs","options","use_cache","wait_for_model","ok","Error","data","json","error","fallbackScore","alignItems","spacing","children","grow","shrink","fileName","_jsxFileName","lineNumber","columnNumber","size","toFixed","_c","$RefreshReg$"],"sources":["/Users/syedali/POC/Create UI Threadneedle/columbia-threadneedle-demo/src/view/results/ResultHallucinationScore.tsx"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { VuiBadge, VuiFlexContainer, VuiFlexItem, VuiText, VuiTextColor } from \"../../ui\";\nimport { SearchResultWithSnippet } from \"../types\";\nimport { useConfigContext } from \"../../contexts/ConfigurationContext\";\n\n// Known confidence levels for hallucination scores\nexport type ConfidenceLevel = \"unavailable\" | \"low\" | \"medium\" | \"high\";\n\n// Map a numerical score to a confidence level\nconst getConfidenceLevel = (score: number): ConfidenceLevel => {\n  if (score < 0) {\n    return \"unavailable\";\n  }\n  if (score <= 0.33) {\n    return \"low\";\n  }\n  if (score <= 0.66) {\n    return \"medium\";\n  }\n  return \"high\";\n};\n\n// Get color and label for the badge based on confidence level\nconst getBadgeProps = (\n  confidenceLevel: ConfidenceLevel\n): { color: \"success\" | \"warning\" | \"danger\" | \"neutral\"; label: string } => {\n  switch (confidenceLevel) {\n    case \"low\":\n      return { color: \"success\", label: \"Low Risk\" };\n    case \"medium\":\n      return { color: \"warning\", label: \"Medium Risk\" };\n    case \"high\":\n      return { color: \"danger\", label: \"High Risk\" };\n    case \"unavailable\":\n    default:\n      return { color: \"neutral\", label: \"Score N/A\" };\n  }\n};\n\n// Check for precomputed FCS scores in result metadata\nconst checkMetadataForScores = (result: SearchResultWithSnippet): number => {\n  // List of possible metadata field names for FCS scores\n  const possibleMetadataNames = [\n    'fcs_score',\n    'fcs',\n    'factual_consistency_score',\n    'hallucination_score',\n    'hallucination_risk',\n    'hhem_score',\n    'consistency_score',\n    'fact_score'\n  ];\n  \n  if (result.document_metadata) {\n    // Check each possible metadata name\n    for (const name of possibleMetadataNames) {\n      const scoreValue = result.document_metadata[name];\n      if (scoreValue !== undefined && scoreValue !== null) {\n        // Try to parse the score to a number if it's not already\n        const score = typeof scoreValue === 'number' \n          ? scoreValue \n          : parseFloat(String(scoreValue));\n        \n        // Return the score if it's a valid number between 0 and 1\n        if (!isNaN(score) && score >= 0 && score <= 1) {\n          console.log(`Found precomputed FCS score in metadata: ${name} = ${score}`);\n          return score;\n        }\n      }\n    }\n  }\n  \n  // Also check part_metadata if available\n  if (result.part_metadata) {\n    // Check each possible metadata name\n    for (const name of possibleMetadataNames) {\n      const scoreValue = result.part_metadata[name];\n      if (scoreValue !== undefined && scoreValue !== null) {\n        // Try to parse the score to a number if it's not already\n        const score = typeof scoreValue === 'number' \n          ? scoreValue \n          : parseFloat(String(scoreValue));\n        \n        // Return the score if it's a valid number between 0 and 1\n        if (!isNaN(score) && score >= 0 && score <= 1) {\n          console.log(`Found precomputed FCS score in part_metadata: ${name} = ${score}`);\n          return score;\n        }\n      }\n    }\n  }\n  \n  // Return -1 if no valid score was found\n  return -1;\n};\n\n// Generate a fallback score based on text similarity\nconst generateFallbackScore = (premise: string, hypothesis: string): number => {\n  // Algorithm for generating a semi-meaningful score rather than purely random\n  const premiseWords = new Set(premise.toLowerCase().split(/\\s+/));\n  const hypothesisWords = hypothesis.toLowerCase().split(/\\s+/);\n  \n  // Count matching words\n  const matchingWords = hypothesisWords.filter(word => premiseWords.has(word)).length;\n  \n  // Calculate a basic relevance score based on word overlap and length\n  const wordMatchRatio = hypothesisWords.length > 0 ? matchingWords / hypothesisWords.length : 0;\n  const lengthRatio = Math.min(1, premise.length / Math.max(1, hypothesis.length * 10));\n  \n  // Combine factors for a final score between 0.1 and 0.9\n  return Math.min(0.9, Math.max(0.1, (wordMatchRatio * 0.7 + lengthRatio * 0.3)));\n};\n\ninterface ResultHallucinationScoreProps {\n  result: SearchResultWithSnippet;\n}\n\n// Always use direct API in production since Netlify Functions are not set up\nconst API_ENDPOINT = \"https://api-inference.huggingface.co/models/vectara/hallucination_evaluation_model\";\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport const ResultHallucinationScore = ({ result }: ResultHallucinationScoreProps) => {\n  const { search } = useConfigContext();\n  const [hallucinationScore, setHallucinationScore] = useState<number>(-1);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [scoreSource, setScoreSource] = useState<string>('');\n\n  useEffect(() => {\n    const evaluateHallucination = async () => {\n      setIsLoading(true);\n      \n      try {\n        // First check if the result has a precomputed FCS score in its metadata\n        const metadataScore = checkMetadataForScores(result);\n        if (metadataScore >= 0) {\n          setHallucinationScore(metadataScore);\n          setScoreSource('metadata');\n          setIsLoading(false);\n          return;\n        }\n        \n        // Get the query from sessionStorage if available\n        const searchQuery = sessionStorage.getItem('lastQuery') || \"search query\";\n        \n        // Format the snippet content\n        const { snippet } = result;\n        const premise = `${snippet.pre} ${snippet.text} ${snippet.post}`;\n        \n        if (!isProduction) {\n          // Mock implementation for development - simulate API call delay\n          await new Promise(resolve => setTimeout(resolve, 500));\n          \n          // Generate a random score between 0.1 and 0.9 for testing\n          const mockScore = Math.round((Math.random() * 0.8 + 0.1) * 100) / 100;\n          setHallucinationScore(mockScore);\n          setScoreSource('dev');\n        } else {\n          try {\n            // Try direct API call to Hugging Face with proper CORS headers\n            const prompt = `<pad> Determine if the hypothesis is true given the premise?\\n\\nPremise: ${premise}\\n\\nHypothesis: ${searchQuery}`;\n            \n            const response = await fetch(API_ENDPOINT, {\n              method: 'POST',\n              headers: {\n                'Authorization': `Bearer ${search.hfToken}`,\n                'Content-Type': 'application/json',\n                'Origin': window.location.origin\n              },\n              body: JSON.stringify({ \n                inputs: prompt,\n                options: { \n                  use_cache: true, \n                  wait_for_model: true\n                }\n              })\n            });\n            \n            if (!response.ok) {\n              // If direct API call fails, use our fallback mechanism\n              throw new Error(\"API call failed\");\n            }\n            \n            const data = await response.json();\n            let score = -1;\n            \n            // Try to find the \"consistent\" label\n            for (const result of data) {\n              if (result.label === \"consistent\") {\n                score = Math.round(result.score * 100) / 100;\n                break;\n              }\n            }\n            \n            // If consistent score not found but we have results, use first score\n            if (score === -1 && data.length > 0) {\n              score = Math.round(data[0].score * 100) / 100;\n            }\n            \n            setHallucinationScore(score);\n            setScoreSource('api');\n          } catch (error) {\n            console.log(\"Direct API call failed, using fallback scoring mechanism\");\n            // Use our own scoring algorithm as a fallback\n            const fallbackScore = generateFallbackScore(premise, searchQuery);\n            setHallucinationScore(Math.round(fallbackScore * 100) / 100);\n            setScoreSource('fallback');\n          }\n        }\n      } catch (error) {\n        console.error(\"Error evaluating hallucination:\", error);\n        setHallucinationScore(-1);\n        setScoreSource('error');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    evaluateHallucination();\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [result, search.hfToken]);\n\n  const confidenceLevel = getConfidenceLevel(hallucinationScore);\n  const { color, label } = getBadgeProps(confidenceLevel);\n\n  return (\n    <VuiFlexContainer alignItems=\"center\" spacing=\"xs\">\n      <VuiFlexItem grow={false} shrink={false}>\n        <VuiBadge color={color}>\n          {isLoading ? \"Evaluating...\" : label}\n        </VuiBadge>\n      </VuiFlexItem>\n      {hallucinationScore >= 0 && !isLoading && (\n        <VuiFlexItem grow={false} shrink={false}>\n          <VuiText size=\"xs\">\n            <p>\n              <VuiTextColor color=\"subdued\">\n                FCS: {hallucinationScore.toFixed(2)}\n                {process.env.NODE_ENV !== 'production' && scoreSource && ` (${scoreSource})`}\n              </VuiTextColor>\n            </p>\n          </VuiText>\n        </VuiFlexItem>\n      )}\n    </VuiFlexContainer>\n  );\n}; "],"mappings":";;AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C,SAASC,QAAQ,EAAEC,gBAAgB,EAAEC,WAAW,EAAEC,OAAO,EAAEC,YAAY,QAAQ,UAAU;AAEzF,SAASC,gBAAgB,QAAQ,qCAAqC;;AAEtE;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAGA;AACA,MAAMC,kBAAkB,GAAIC,KAAa,IAAsB;EAC7D,IAAIA,KAAK,GAAG,CAAC,EAAE;IACb,OAAO,aAAa;EACtB;EACA,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjB,OAAO,KAAK;EACd;EACA,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjB,OAAO,QAAQ;EACjB;EACA,OAAO,MAAM;AACf,CAAC;;AAED;AACA,MAAMC,aAAa,GACjBC,eAAgC,IAC2C;EAC3E,QAAQA,eAAe;IACrB,KAAK,KAAK;MACR,OAAO;QAAEC,KAAK,EAAE,SAAS;QAAEC,KAAK,EAAE;MAAW,CAAC;IAChD,KAAK,QAAQ;MACX,OAAO;QAAED,KAAK,EAAE,SAAS;QAAEC,KAAK,EAAE;MAAc,CAAC;IACnD,KAAK,MAAM;MACT,OAAO;QAAED,KAAK,EAAE,QAAQ;QAAEC,KAAK,EAAE;MAAY,CAAC;IAChD,KAAK,aAAa;IAClB;MACE,OAAO;QAAED,KAAK,EAAE,SAAS;QAAEC,KAAK,EAAE;MAAY,CAAC;EACnD;AACF,CAAC;;AAED;AACA,MAAMC,sBAAsB,GAAIC,MAA+B,IAAa;EAC1E;EACA,MAAMC,qBAAqB,GAAG,CAC5B,WAAW,EACX,KAAK,EACL,2BAA2B,EAC3B,qBAAqB,EACrB,oBAAoB,EACpB,YAAY,EACZ,mBAAmB,EACnB,YAAY,CACb;EAED,IAAID,MAAM,CAACE,iBAAiB,EAAE;IAC5B;IACA,KAAK,MAAMC,IAAI,IAAIF,qBAAqB,EAAE;MACxC,MAAMG,UAAU,GAAGJ,MAAM,CAACE,iBAAiB,CAACC,IAAI,CAAC;MACjD,IAAIC,UAAU,KAAKC,SAAS,IAAID,UAAU,KAAK,IAAI,EAAE;QACnD;QACA,MAAMV,KAAK,GAAG,OAAOU,UAAU,KAAK,QAAQ,GACxCA,UAAU,GACVE,UAAU,CAACC,MAAM,CAACH,UAAU,CAAC,CAAC;;QAElC;QACA,IAAI,CAACI,KAAK,CAACd,KAAK,CAAC,IAAIA,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,EAAE;UAC7Ce,OAAO,CAACC,GAAG,CAAC,4CAA4CP,IAAI,MAAMT,KAAK,EAAE,CAAC;UAC1E,OAAOA,KAAK;QACd;MACF;IACF;EACF;;EAEA;EACA,IAAIM,MAAM,CAACW,aAAa,EAAE;IACxB;IACA,KAAK,MAAMR,IAAI,IAAIF,qBAAqB,EAAE;MACxC,MAAMG,UAAU,GAAGJ,MAAM,CAACW,aAAa,CAACR,IAAI,CAAC;MAC7C,IAAIC,UAAU,KAAKC,SAAS,IAAID,UAAU,KAAK,IAAI,EAAE;QACnD;QACA,MAAMV,KAAK,GAAG,OAAOU,UAAU,KAAK,QAAQ,GACxCA,UAAU,GACVE,UAAU,CAACC,MAAM,CAACH,UAAU,CAAC,CAAC;;QAElC;QACA,IAAI,CAACI,KAAK,CAACd,KAAK,CAAC,IAAIA,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,EAAE;UAC7Ce,OAAO,CAACC,GAAG,CAAC,iDAAiDP,IAAI,MAAMT,KAAK,EAAE,CAAC;UAC/E,OAAOA,KAAK;QACd;MACF;IACF;EACF;;EAEA;EACA,OAAO,CAAC,CAAC;AACX,CAAC;;AAED;AACA,MAAMkB,qBAAqB,GAAGA,CAACC,OAAe,EAAEC,UAAkB,KAAa;EAC7E;EACA,MAAMC,YAAY,GAAG,IAAIC,GAAG,CAACH,OAAO,CAACI,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC,CAAC;EAChE,MAAMC,eAAe,GAAGL,UAAU,CAACG,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC;;EAE7D;EACA,MAAME,aAAa,GAAGD,eAAe,CAACE,MAAM,CAACC,IAAI,IAAIP,YAAY,CAACQ,GAAG,CAACD,IAAI,CAAC,CAAC,CAACE,MAAM;;EAEnF;EACA,MAAMC,cAAc,GAAGN,eAAe,CAACK,MAAM,GAAG,CAAC,GAAGJ,aAAa,GAAGD,eAAe,CAACK,MAAM,GAAG,CAAC;EAC9F,MAAME,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEf,OAAO,CAACW,MAAM,GAAGG,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEf,UAAU,CAACU,MAAM,GAAG,EAAE,CAAC,CAAC;;EAErF;EACA,OAAOG,IAAI,CAACC,GAAG,CAAC,GAAG,EAAED,IAAI,CAACE,GAAG,CAAC,GAAG,EAAGJ,cAAc,GAAG,GAAG,GAAGC,WAAW,GAAG,GAAI,CAAC,CAAC;AACjF,CAAC;AAMD;AACA,MAAMI,YAAY,GAAG,oFAAoF;AACzG,MAAMC,YAAY,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY;AAE1D,OAAO,MAAMC,wBAAwB,GAAGA,CAAC;EAAEnC;AAAsC,CAAC,KAAK;EAAAoC,EAAA;EACrF,MAAM;IAAEC;EAAO,CAAC,GAAG/C,gBAAgB,CAAC,CAAC;EACrC,MAAM,CAACgD,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGxD,QAAQ,CAAS,CAAC,CAAC,CAAC;EACxE,MAAM,CAACyD,SAAS,EAAEC,YAAY,CAAC,GAAG1D,QAAQ,CAAU,KAAK,CAAC;EAC1D,MAAM,CAAC2D,WAAW,EAAEC,cAAc,CAAC,GAAG5D,QAAQ,CAAS,EAAE,CAAC;EAE1DC,SAAS,CAAC,MAAM;IACd,MAAM4D,qBAAqB,GAAG,MAAAA,CAAA,KAAY;MACxCH,YAAY,CAAC,IAAI,CAAC;MAElB,IAAI;QACF;QACA,MAAMI,aAAa,GAAG9C,sBAAsB,CAACC,MAAM,CAAC;QACpD,IAAI6C,aAAa,IAAI,CAAC,EAAE;UACtBN,qBAAqB,CAACM,aAAa,CAAC;UACpCF,cAAc,CAAC,UAAU,CAAC;UAC1BF,YAAY,CAAC,KAAK,CAAC;UACnB;QACF;;QAEA;QACA,MAAMK,WAAW,GAAGC,cAAc,CAACC,OAAO,CAAC,WAAW,CAAC,IAAI,cAAc;;QAEzE;QACA,MAAM;UAAEC;QAAQ,CAAC,GAAGjD,MAAM;QAC1B,MAAMa,OAAO,GAAG,GAAGoC,OAAO,CAACC,GAAG,IAAID,OAAO,CAACE,IAAI,IAAIF,OAAO,CAACG,IAAI,EAAE;QAEhE,IAAI,CAACrB,YAAY,EAAE;UACjB;UACA,MAAM,IAAIsB,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;;UAEtD;UACA,MAAME,SAAS,GAAG7B,IAAI,CAAC8B,KAAK,CAAC,CAAC9B,IAAI,CAAC+B,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,GAAG;UACrEnB,qBAAqB,CAACiB,SAAS,CAAC;UAChCb,cAAc,CAAC,KAAK,CAAC;QACvB,CAAC,MAAM;UACL,IAAI;YACF;YACA,MAAMgB,MAAM,GAAG,4EAA4E9C,OAAO,mBAAmBiC,WAAW,EAAE;YAElI,MAAMc,QAAQ,GAAG,MAAMC,KAAK,CAAC/B,YAAY,EAAE;cACzCgC,MAAM,EAAE,MAAM;cACdC,OAAO,EAAE;gBACP,eAAe,EAAE,UAAU1B,MAAM,CAAC2B,OAAO,EAAE;gBAC3C,cAAc,EAAE,kBAAkB;gBAClC,QAAQ,EAAEC,MAAM,CAACC,QAAQ,CAACC;cAC5B,CAAC;cACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;gBACnBC,MAAM,EAAEZ,MAAM;gBACda,OAAO,EAAE;kBACPC,SAAS,EAAE,IAAI;kBACfC,cAAc,EAAE;gBAClB;cACF,CAAC;YACH,CAAC,CAAC;YAEF,IAAI,CAACd,QAAQ,CAACe,EAAE,EAAE;cAChB;cACA,MAAM,IAAIC,KAAK,CAAC,iBAAiB,CAAC;YACpC;YAEA,MAAMC,IAAI,GAAG,MAAMjB,QAAQ,CAACkB,IAAI,CAAC,CAAC;YAClC,IAAIpF,KAAK,GAAG,CAAC,CAAC;;YAEd;YACA,KAAK,MAAMM,MAAM,IAAI6E,IAAI,EAAE;cACzB,IAAI7E,MAAM,CAACF,KAAK,KAAK,YAAY,EAAE;gBACjCJ,KAAK,GAAGiC,IAAI,CAAC8B,KAAK,CAACzD,MAAM,CAACN,KAAK,GAAG,GAAG,CAAC,GAAG,GAAG;gBAC5C;cACF;YACF;;YAEA;YACA,IAAIA,KAAK,KAAK,CAAC,CAAC,IAAImF,IAAI,CAACrD,MAAM,GAAG,CAAC,EAAE;cACnC9B,KAAK,GAAGiC,IAAI,CAAC8B,KAAK,CAACoB,IAAI,CAAC,CAAC,CAAC,CAACnF,KAAK,GAAG,GAAG,CAAC,GAAG,GAAG;YAC/C;YAEA6C,qBAAqB,CAAC7C,KAAK,CAAC;YAC5BiD,cAAc,CAAC,KAAK,CAAC;UACvB,CAAC,CAAC,OAAOoC,KAAK,EAAE;YACdtE,OAAO,CAACC,GAAG,CAAC,0DAA0D,CAAC;YACvE;YACA,MAAMsE,aAAa,GAAGpE,qBAAqB,CAACC,OAAO,EAAEiC,WAAW,CAAC;YACjEP,qBAAqB,CAACZ,IAAI,CAAC8B,KAAK,CAACuB,aAAa,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC;YAC5DrC,cAAc,CAAC,UAAU,CAAC;UAC5B;QACF;MACF,CAAC,CAAC,OAAOoC,KAAK,EAAE;QACdtE,OAAO,CAACsE,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;QACvDxC,qBAAqB,CAAC,CAAC,CAAC,CAAC;QACzBI,cAAc,CAAC,OAAO,CAAC;MACzB,CAAC,SAAS;QACRF,YAAY,CAAC,KAAK,CAAC;MACrB;IACF,CAAC;IAEDG,qBAAqB,CAAC,CAAC;IACzB;EACA,CAAC,EAAE,CAAC5C,MAAM,EAAEqC,MAAM,CAAC2B,OAAO,CAAC,CAAC;EAE5B,MAAMpE,eAAe,GAAGH,kBAAkB,CAAC6C,kBAAkB,CAAC;EAC9D,MAAM;IAAEzC,KAAK;IAAEC;EAAM,CAAC,GAAGH,aAAa,CAACC,eAAe,CAAC;EAEvD,oBACEJ,OAAA,CAACN,gBAAgB;IAAC+F,UAAU,EAAC,QAAQ;IAACC,OAAO,EAAC,IAAI;IAAAC,QAAA,gBAChD3F,OAAA,CAACL,WAAW;MAACiG,IAAI,EAAE,KAAM;MAACC,MAAM,EAAE,KAAM;MAAAF,QAAA,eACtC3F,OAAA,CAACP,QAAQ;QAACY,KAAK,EAAEA,KAAM;QAAAsF,QAAA,EACpB3C,SAAS,GAAG,eAAe,GAAG1C;MAAK;QAAAwF,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAC5B;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACA,CAAC,EACbnD,kBAAkB,IAAI,CAAC,IAAI,CAACE,SAAS,iBACpChD,OAAA,CAACL,WAAW;MAACiG,IAAI,EAAE,KAAM;MAACC,MAAM,EAAE,KAAM;MAAAF,QAAA,eACtC3F,OAAA,CAACJ,OAAO;QAACsG,IAAI,EAAC,IAAI;QAAAP,QAAA,eAChB3F,OAAA;UAAA2F,QAAA,eACE3F,OAAA,CAACH,YAAY;YAACQ,KAAK,EAAC,SAAS;YAAAsF,QAAA,GAAC,OACvB,EAAC7C,kBAAkB,CAACqD,OAAO,CAAC,CAAC,CAAC,EAClC3D,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IAAIQ,WAAW,IAAI,KAAKA,WAAW,GAAG;UAAA;YAAA4C,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAChE;QAAC;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACd;MAAC;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACG;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACC,CACd;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACe,CAAC;AAEvB,CAAC;AAACrD,EAAA,CA5HWD,wBAAwB;EAAA,QAChB7C,gBAAgB;AAAA;AAAAsG,EAAA,GADxBzD,wBAAwB;AAAA,IAAAyD,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}