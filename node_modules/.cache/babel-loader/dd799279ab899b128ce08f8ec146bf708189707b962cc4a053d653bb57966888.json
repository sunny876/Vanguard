{"ast":null,"code":"import{useState,useEffect}from\"react\";import{useConfigContext}from\"../../contexts/ConfigurationContext\";// Known confidence levels for hallucination scores\n// Map a numerical score to a confidence level\nconst getConfidenceLevel=score=>{if(score<0){return\"unavailable\";}if(score<=0.33){return\"high\";}if(score<=0.66){return\"medium\";}return\"low\";};// Get color and label for the badge based on confidence level\nconst getBadgeProps=confidenceLevel=>{switch(confidenceLevel){case\"low\":return{color:\"success\",label:\"Low Risk\"};case\"medium\":return{color:\"warning\",label:\"Medium Risk\"};case\"high\":return{color:\"danger\",label:\"High Risk\"};case\"unavailable\":default:return{color:\"neutral\",label:\"Score N/A\"};}};// Check for precomputed FCS scores in result metadata\nexport const getFcsScore=result=>{// List of possible metadata field names for FCS scores\nconst possibleMetadataNames=['fcs_score','fcs','factual_consistency_score','hallucination_score','hallucination_risk','hhem_score','consistency_score','fact_score'];if(result.document_metadata){// Check each possible metadata name\nfor(const name of possibleMetadataNames){const scoreValue=result.document_metadata[name];if(scoreValue!==undefined&&scoreValue!==null){// Try to parse the score to a number if it's not already\nconst score=typeof scoreValue==='number'?scoreValue:parseFloat(String(scoreValue));// Return the score if it's a valid number between 0 and 1\nif(!isNaN(score)&&score>=0&&score<=1){console.log(`Found precomputed FCS score in metadata: ${name} = ${score}`);return score;}}}}// Also check part_metadata if available\nif(result.part_metadata){// Check each possible metadata name\nfor(const name of possibleMetadataNames){const scoreValue=result.part_metadata[name];if(scoreValue!==undefined&&scoreValue!==null){// Try to parse the score to a number if it's not already\nconst score=typeof scoreValue==='number'?scoreValue:parseFloat(String(scoreValue));// Return the score if it's a valid number between 0 and 1\nif(!isNaN(score)&&score>=0&&score<=1){console.log(`Found precomputed FCS score in part_metadata: ${name} = ${score}`);return score;}}}}// Return -1 if no valid score was found\nreturn-1;};// Use the exported function for internal use too\nconst checkMetadataForScores=getFcsScore;// Generate a fallback score based on text similarity\nconst generateFallbackScore=(premise,hypothesis)=>{// Algorithm for generating a semi-meaningful score rather than purely random\nconst premiseWords=new Set(premise.toLowerCase().split(/\\s+/));const hypothesisWords=hypothesis.toLowerCase().split(/\\s+/);// Count matching words\nconst matchingWords=hypothesisWords.filter(word=>premiseWords.has(word)).length;// Calculate a basic relevance score based on word overlap and length\nconst wordMatchRatio=hypothesisWords.length>0?matchingWords/hypothesisWords.length:0;const lengthRatio=Math.min(1,premise.length/Math.max(1,hypothesis.length*10));// Combine factors for a final score between 0.1 and 0.9\nreturn Math.min(0.9,Math.max(0.1,wordMatchRatio*0.7+lengthRatio*0.3));};// Always use direct API in production since Netlify Functions are not set up\nconst API_ENDPOINT=\"https://api-inference.huggingface.co/models/vectara/hallucination_evaluation_model\";const isProduction=process.env.NODE_ENV==='production';export const ResultHallucinationScore=_ref=>{let{result}=_ref;const{search}=useConfigContext();const[hallucinationScore,setHallucinationScore]=useState(-1);const[isLoading,setIsLoading]=useState(false);const[scoreSource,setScoreSource]=useState('');useEffect(()=>{const evaluateHallucination=async()=>{setIsLoading(true);try{// First check if the result has a precomputed FCS score in its metadata\nconst metadataScore=checkMetadataForScores(result);if(metadataScore>=0){setHallucinationScore(metadataScore);setScoreSource('metadata');setIsLoading(false);return;}// Get the query from sessionStorage if available\nconst searchQuery=sessionStorage.getItem('lastQuery')||\"search query\";// Format the snippet content\nconst{snippet}=result;const premise=`${snippet.pre} ${snippet.text} ${snippet.post}`;if(!isProduction){// Mock implementation for development - simulate API call delay\nawait new Promise(resolve=>setTimeout(resolve,500));// Generate a random score between 0.1 and 0.9 for testing\nconst mockScore=Math.round((Math.random()*0.8+0.1)*100)/100;setHallucinationScore(mockScore);setScoreSource('dev');}else{try{// Try direct API call to Hugging Face with proper CORS headers\nconst prompt=`<pad> Determine if the hypothesis is true given the premise?\\n\\nPremise: ${premise}\\n\\nHypothesis: ${searchQuery}`;const response=await fetch(API_ENDPOINT,{method:'POST',headers:{'Authorization':`Bearer ${search.hfToken}`,'Content-Type':'application/json','Origin':window.location.origin},body:JSON.stringify({inputs:prompt,options:{use_cache:true,wait_for_model:true}})});if(!response.ok){// If direct API call fails, use our fallback mechanism\nthrow new Error(\"API call failed\");}const data=await response.json();let score=-1;// Try to find the \"consistent\" label\nfor(const result of data){if(result.label===\"consistent\"){score=Math.round(result.score*100)/100;break;}}// If consistent score not found but we have results, use first score\nif(score===-1&&data.length>0){score=Math.round(data[0].score*100)/100;}setHallucinationScore(score);setScoreSource('api');}catch(error){console.log(\"Direct API call failed, using fallback scoring mechanism\");// Use our own scoring algorithm as a fallback\nconst fallbackScore=generateFallbackScore(premise,searchQuery);setHallucinationScore(Math.round(fallbackScore*100)/100);setScoreSource('fallback');}}}catch(error){console.error(\"Error evaluating hallucination:\",error);setHallucinationScore(-1);setScoreSource('error');}finally{setIsLoading(false);}};evaluateHallucination();// eslint-disable-next-line react-hooks/exhaustive-deps\n},[result,search.hfToken]);// We're still calculating the scores behind the scenes for sorting purposes,\n// but we're not displaying them visually anymore\nreturn null;};","map":{"version":3,"names":["useState","useEffect","useConfigContext","getConfidenceLevel","score","getBadgeProps","confidenceLevel","color","label","getFcsScore","result","possibleMetadataNames","document_metadata","name","scoreValue","undefined","parseFloat","String","isNaN","console","log","part_metadata","checkMetadataForScores","generateFallbackScore","premise","hypothesis","premiseWords","Set","toLowerCase","split","hypothesisWords","matchingWords","filter","word","has","length","wordMatchRatio","lengthRatio","Math","min","max","API_ENDPOINT","isProduction","process","env","NODE_ENV","ResultHallucinationScore","_ref","search","hallucinationScore","setHallucinationScore","isLoading","setIsLoading","scoreSource","setScoreSource","evaluateHallucination","metadataScore","searchQuery","sessionStorage","getItem","snippet","pre","text","post","Promise","resolve","setTimeout","mockScore","round","random","prompt","response","fetch","method","headers","hfToken","window","location","origin","body","JSON","stringify","inputs","options","use_cache","wait_for_model","ok","Error","data","json","error","fallbackScore"],"sources":["/Users/syedali/POC/Create UI Threadneedle/columbia-threadneedle-demo/src/view/results/ResultHallucinationScore.tsx"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { VuiBadge, VuiFlexContainer, VuiFlexItem, VuiText, VuiTextColor } from \"../../ui\";\nimport { SearchResultWithSnippet } from \"../types\";\nimport { useConfigContext } from \"../../contexts/ConfigurationContext\";\n\n// Known confidence levels for hallucination scores\nexport type ConfidenceLevel = \"unavailable\" | \"low\" | \"medium\" | \"high\";\n\n// Map a numerical score to a confidence level\nconst getConfidenceLevel = (score: number): ConfidenceLevel => {\n  if (score < 0) {\n    return \"unavailable\";\n  }\n  if (score <= 0.33) {\n    return \"high\";\n  }\n  if (score <= 0.66) {\n    return \"medium\";\n  }\n  return \"low\";\n};\n\n// Get color and label for the badge based on confidence level\nconst getBadgeProps = (\n  confidenceLevel: ConfidenceLevel\n): { color: \"success\" | \"warning\" | \"danger\" | \"neutral\"; label: string } => {\n  switch (confidenceLevel) {\n    case \"low\":\n      return { color: \"success\", label: \"Low Risk\" };\n    case \"medium\":\n      return { color: \"warning\", label: \"Medium Risk\" };\n    case \"high\":\n      return { color: \"danger\", label: \"High Risk\" };\n    case \"unavailable\":\n    default:\n      return { color: \"neutral\", label: \"Score N/A\" };\n  }\n};\n\n// Check for precomputed FCS scores in result metadata\nexport const getFcsScore = (result: SearchResultWithSnippet): number => {\n  // List of possible metadata field names for FCS scores\n  const possibleMetadataNames = [\n    'fcs_score',\n    'fcs',\n    'factual_consistency_score',\n    'hallucination_score',\n    'hallucination_risk',\n    'hhem_score',\n    'consistency_score',\n    'fact_score'\n  ];\n  \n  if (result.document_metadata) {\n    // Check each possible metadata name\n    for (const name of possibleMetadataNames) {\n      const scoreValue = result.document_metadata[name];\n      if (scoreValue !== undefined && scoreValue !== null) {\n        // Try to parse the score to a number if it's not already\n        const score = typeof scoreValue === 'number' \n          ? scoreValue \n          : parseFloat(String(scoreValue));\n        \n        // Return the score if it's a valid number between 0 and 1\n        if (!isNaN(score) && score >= 0 && score <= 1) {\n          console.log(`Found precomputed FCS score in metadata: ${name} = ${score}`);\n          return score;\n        }\n      }\n    }\n  }\n  \n  // Also check part_metadata if available\n  if (result.part_metadata) {\n    // Check each possible metadata name\n    for (const name of possibleMetadataNames) {\n      const scoreValue = result.part_metadata[name];\n      if (scoreValue !== undefined && scoreValue !== null) {\n        // Try to parse the score to a number if it's not already\n        const score = typeof scoreValue === 'number' \n          ? scoreValue \n          : parseFloat(String(scoreValue));\n        \n        // Return the score if it's a valid number between 0 and 1\n        if (!isNaN(score) && score >= 0 && score <= 1) {\n          console.log(`Found precomputed FCS score in part_metadata: ${name} = ${score}`);\n          return score;\n        }\n      }\n    }\n  }\n  \n  // Return -1 if no valid score was found\n  return -1;\n};\n\n// Use the exported function for internal use too\nconst checkMetadataForScores = getFcsScore;\n\n// Generate a fallback score based on text similarity\nconst generateFallbackScore = (premise: string, hypothesis: string): number => {\n  // Algorithm for generating a semi-meaningful score rather than purely random\n  const premiseWords = new Set(premise.toLowerCase().split(/\\s+/));\n  const hypothesisWords = hypothesis.toLowerCase().split(/\\s+/);\n  \n  // Count matching words\n  const matchingWords = hypothesisWords.filter(word => premiseWords.has(word)).length;\n  \n  // Calculate a basic relevance score based on word overlap and length\n  const wordMatchRatio = hypothesisWords.length > 0 ? matchingWords / hypothesisWords.length : 0;\n  const lengthRatio = Math.min(1, premise.length / Math.max(1, hypothesis.length * 10));\n  \n  // Combine factors for a final score between 0.1 and 0.9\n  return Math.min(0.9, Math.max(0.1, (wordMatchRatio * 0.7 + lengthRatio * 0.3)));\n};\n\ninterface ResultHallucinationScoreProps {\n  result: SearchResultWithSnippet;\n}\n\n// Always use direct API in production since Netlify Functions are not set up\nconst API_ENDPOINT = \"https://api-inference.huggingface.co/models/vectara/hallucination_evaluation_model\";\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport const ResultHallucinationScore = ({ result }: ResultHallucinationScoreProps) => {\n  const { search } = useConfigContext();\n  const [hallucinationScore, setHallucinationScore] = useState<number>(-1);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [scoreSource, setScoreSource] = useState<string>('');\n\n  useEffect(() => {\n    const evaluateHallucination = async () => {\n      setIsLoading(true);\n      \n      try {\n        // First check if the result has a precomputed FCS score in its metadata\n        const metadataScore = checkMetadataForScores(result);\n        if (metadataScore >= 0) {\n          setHallucinationScore(metadataScore);\n          setScoreSource('metadata');\n          setIsLoading(false);\n          return;\n        }\n        \n        // Get the query from sessionStorage if available\n        const searchQuery = sessionStorage.getItem('lastQuery') || \"search query\";\n        \n        // Format the snippet content\n        const { snippet } = result;\n        const premise = `${snippet.pre} ${snippet.text} ${snippet.post}`;\n        \n        if (!isProduction) {\n          // Mock implementation for development - simulate API call delay\n          await new Promise(resolve => setTimeout(resolve, 500));\n          \n          // Generate a random score between 0.1 and 0.9 for testing\n          const mockScore = Math.round((Math.random() * 0.8 + 0.1) * 100) / 100;\n          setHallucinationScore(mockScore);\n          setScoreSource('dev');\n        } else {\n          try {\n            // Try direct API call to Hugging Face with proper CORS headers\n            const prompt = `<pad> Determine if the hypothesis is true given the premise?\\n\\nPremise: ${premise}\\n\\nHypothesis: ${searchQuery}`;\n            \n            const response = await fetch(API_ENDPOINT, {\n              method: 'POST',\n              headers: {\n                'Authorization': `Bearer ${search.hfToken}`,\n                'Content-Type': 'application/json',\n                'Origin': window.location.origin\n              },\n              body: JSON.stringify({ \n                inputs: prompt,\n                options: { \n                  use_cache: true, \n                  wait_for_model: true\n                }\n              })\n            });\n            \n            if (!response.ok) {\n              // If direct API call fails, use our fallback mechanism\n              throw new Error(\"API call failed\");\n            }\n            \n            const data = await response.json();\n            let score = -1;\n            \n            // Try to find the \"consistent\" label\n            for (const result of data) {\n              if (result.label === \"consistent\") {\n                score = Math.round(result.score * 100) / 100;\n                break;\n              }\n            }\n            \n            // If consistent score not found but we have results, use first score\n            if (score === -1 && data.length > 0) {\n              score = Math.round(data[0].score * 100) / 100;\n            }\n            \n            setHallucinationScore(score);\n            setScoreSource('api');\n          } catch (error) {\n            console.log(\"Direct API call failed, using fallback scoring mechanism\");\n            // Use our own scoring algorithm as a fallback\n            const fallbackScore = generateFallbackScore(premise, searchQuery);\n            setHallucinationScore(Math.round(fallbackScore * 100) / 100);\n            setScoreSource('fallback');\n          }\n        }\n      } catch (error) {\n        console.error(\"Error evaluating hallucination:\", error);\n        setHallucinationScore(-1);\n        setScoreSource('error');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    evaluateHallucination();\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [result, search.hfToken]);\n\n  // We're still calculating the scores behind the scenes for sorting purposes,\n  // but we're not displaying them visually anymore\n  return null;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}