{"ast":null,"code":"var _jsxFileName = \"/Users/syedali/POC/Create UI Threadneedle/columbia-threadneedle-demo/src/contexts/SearchContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { createContext, useContext, useState, useEffect, useRef } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\nimport { mmrRerankerId } from \"../view/types\";\nimport { useConfigContext } from \"./ConfigurationContext\";\nimport { addHistoryItem, deleteHistory, retrieveHistory } from \"./history\";\nimport { streamQueryV2 } from \"@vectara/stream-query-client\";\nimport { END_TAG, START_TAG, parseSnippet } from \"../utils/parseSnippet\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SearchContext = /*#__PURE__*/createContext(undefined);\nconst getQueryParam = (urlParams, key) => {\n  const value = urlParams.get(key);\n  if (value) return decodeURIComponent(value);\n  return undefined;\n};\nexport const SearchContextProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    search,\n    rerank,\n    hybrid\n  } = useConfigContext();\n  const [searchValue, setSearchValue] = useState(\"\");\n  const [filterValue, setFilterValue] = useState(\"\");\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Language\n  const [languageValue, setLanguageValue] = useState();\n\n  // History\n  const [history, setHistory] = useState([]);\n\n  // Basic search\n  const [isSearching, setIsSearching] = useState(false);\n  const [searchError, setSearchError] = useState();\n  const [searchResults, setSearchResults] = useState(undefined);\n  const [searchTime, setSearchTime] = useState(0);\n\n  // Summarization\n  const [isSummarizing, setIsSummarizing] = useState(false);\n  const [summarizationError, setSummarizationError] = useState();\n  const [summarizationResponse, setSummarizationResponse] = useState();\n  const [summaryTime, setSummaryTime] = useState(0);\n\n  // Citation selection\n  const searchResultsRef = useRef([]);\n  const [selectedSearchResultPosition, setSelectedSearchResultPosition] = useState();\n  useEffect(() => {\n    setHistory(retrieveHistory());\n  }, []);\n\n  // Use the browser back and forward buttons to traverse history\n  // of searches, and bookmark or share the URL.\n  useEffect(() => {\n    var _getQueryParam;\n    // Search params are updated as part of calling onSearch, so we don't\n    // want to trigger another search when the search params change if that\n    // search is already in progress.\n    if (isSearching) return;\n    const urlParams = new URLSearchParams(searchParams);\n    onSearch({\n      // Set to an empty string to wipe out any existing search value.\n      value: (_getQueryParam = getQueryParam(urlParams, \"query\")) !== null && _getQueryParam !== void 0 ? _getQueryParam : \"\",\n      filter: getQueryParam(urlParams, \"filter\"),\n      language: getQueryParam(urlParams, \"language\"),\n      isPersistable: false\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [searchParams]); // TODO: Add onSearch and fix infinite render loop\n\n  useEffect(() => {\n    if (searchResults) {\n      searchResultsRef.current = searchResultsRef.current.slice(0, searchResults.length);\n    } else {\n      searchResultsRef.current = [];\n    }\n  }, [searchResults]);\n  const clearHistory = () => {\n    setHistory([]);\n    deleteHistory();\n  };\n  const selectSearchResultAt = position => {\n    if (!searchResultsRef.current[position] || selectedSearchResultPosition === position) {\n      // Reset selected position.\n      setSelectedSearchResultPosition(undefined);\n    } else {\n      setSelectedSearchResultPosition(position);\n      // Scroll to the selected search result.\n      window.scrollTo({\n        top: searchResultsRef.current[position].offsetTop - 78,\n        behavior: \"smooth\"\n      });\n    }\n  };\n  const getLanguage = () => languageValue !== null && languageValue !== void 0 ? languageValue : \"auto\";\n  const onSearch = async ({\n    value = searchValue,\n    filter = filterValue,\n    language = getLanguage(),\n    isPersistable = true\n  }) => {\n    setSearchValue(value);\n    setFilterValue(filter);\n    setLanguageValue(language);\n    setSearchError(undefined);\n    setSummarizationError(undefined);\n    setSummarizationResponse(undefined);\n    if (value !== null && value !== void 0 && value.trim()) {\n      // Store current search query in sessionStorage for hallucination evaluation\n      sessionStorage.setItem('lastQuery', value);\n\n      // Save to history.\n      setHistory(addHistoryItem({\n        query: value,\n        filter,\n        language\n      }, history));\n\n      // Persist to URL, only if the search executes. This way the prior\n      // search that was persisted remains in the URL if the search doesn't execute.\n      if (isPersistable) {\n        setSearchParams(new URLSearchParams(`?query=${encodeURIComponent(value)}&filter=${encodeURIComponent(filter)}&language=${encodeURIComponent(language)}`));\n      }\n      setIsSearching(true);\n      setIsSummarizing(true);\n      setSelectedSearchResultPosition(undefined);\n      const startTime = Date.now();\n      let resultsWithSnippets;\n      try {\n        const onStreamEvent = event => {\n          switch (event.type) {\n            case \"requestError\":\n            case \"genericError\":\n            case \"unexpectedError\":\n              setSearchError({\n                message: \"Error sending the query request\"\n              });\n              break;\n            case \"error\":\n              setSummarizationError({\n                message: event.messages.join(\", \")\n              });\n              break;\n            case \"searchResults\":\n              setIsSearching(false);\n              setSearchTime(Date.now() - startTime);\n              resultsWithSnippets = event.searchResults.map(result => {\n                const {\n                  pre,\n                  text,\n                  post\n                } = parseSnippet(result.text);\n                return {\n                  ...result,\n                  snippet: {\n                    pre,\n                    text,\n                    post\n                  }\n                };\n              });\n              setSearchResults(resultsWithSnippets);\n              break;\n            case \"generationChunk\":\n              setSummarizationResponse(event.updatedText);\n              break;\n            case \"generationEnd\":\n              setIsSummarizing(false);\n              break;\n            case \"end\":\n              setSummaryTime(Date.now() - startTime);\n              break;\n          }\n        };\n        const streamQueryConfig = {\n          apiKey: search.apiKey,\n          customerId: search.customerId,\n          query: value,\n          corpusKey: search.corpusKey,\n          search: {\n            offset: 0,\n            metadataFilter: \"\",\n            lexicalInterpolation: value.trim().split(\" \").length > hybrid.numWords ? hybrid.lambdaLong : hybrid.lambdaShort,\n            reranker: rerank.isEnabled && rerank.id ? rerank.id === mmrRerankerId ? {\n              type: \"mmr\",\n              diversityBias: 0\n            } : {\n              type: \"customer_reranker\",\n              // rnk_ prefix needed for conversion from API v1 to v2.\n              rerankerId: `rnk_${rerank.id.toString()}`\n            } : undefined,\n            contextConfiguration: {\n              // If sentences/chars context is not displayed properly,\n              // you may need to adjust the CONTEXT_MAX_LENGTH variable\n              // in the components that display reference snippets.\n              sentencesBefore: 2,\n              sentencesAfter: 2,\n              startTag: START_TAG,\n              endTag: END_TAG\n            }\n          },\n          chat: {\n            store: true\n          }\n        };\n        streamQueryV2({\n          streamQueryConfig,\n          onStreamEvent\n        });\n      } catch (error) {\n        console.log(\"Summary error\", error);\n        setIsSummarizing(false);\n        setSummarizationError(error);\n        setSummarizationResponse(undefined);\n        return;\n      }\n    } else {\n      // Persist to URL.\n      if (isPersistable) setSearchParams(new URLSearchParams(\"\"));\n      setSearchResults(undefined);\n      setSummarizationResponse(undefined);\n      setIsSearching(false);\n      setIsSummarizing(false);\n    }\n  };\n  const reset = () => {\n    // Specifically don't reset language because that's more of a\n    // user preference.\n    onSearch({\n      value: \"\",\n      filter: \"\"\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(SearchContext.Provider, {\n    value: {\n      filterValue,\n      setFilterValue,\n      searchValue,\n      setSearchValue,\n      onSearch,\n      reset,\n      isSearching,\n      searchError,\n      searchResults,\n      searchTime,\n      isSummarizing,\n      summarizationError,\n      summarizationResponse,\n      summaryTime,\n      language: getLanguage(),\n      summaryNumResults: 7,\n      summaryNumSentences: 3,\n      summaryPromptName: \"vectara-summary-ext-v1.2.0\",\n      history,\n      clearHistory,\n      searchResultsRef,\n      selectedSearchResultPosition,\n      selectSearchResultAt\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 297,\n    columnNumber: 5\n  }, this);\n};\n_s(SearchContextProvider, \"0Sa9CxMS13kmxIrUzNlwllBs0Qs=\", false, function () {\n  return [useConfigContext, useSearchParams];\n});\n_c = SearchContextProvider;\nexport const useSearchContext = () => {\n  _s2();\n  const context = useContext(SearchContext);\n  if (context === undefined) {\n    throw new Error(\"useSearchContext must be used within a SearchContextProvider\");\n  }\n  return context;\n};\n_s2(useSearchContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SearchContextProvider\");","map":{"version":3,"names":["createContext","useContext","useState","useEffect","useRef","useSearchParams","mmrRerankerId","useConfigContext","addHistoryItem","deleteHistory","retrieveHistory","streamQueryV2","END_TAG","START_TAG","parseSnippet","jsxDEV","_jsxDEV","SearchContext","undefined","getQueryParam","urlParams","key","value","get","decodeURIComponent","SearchContextProvider","children","_s","search","rerank","hybrid","searchValue","setSearchValue","filterValue","setFilterValue","searchParams","setSearchParams","languageValue","setLanguageValue","history","setHistory","isSearching","setIsSearching","searchError","setSearchError","searchResults","setSearchResults","searchTime","setSearchTime","isSummarizing","setIsSummarizing","summarizationError","setSummarizationError","summarizationResponse","setSummarizationResponse","summaryTime","setSummaryTime","searchResultsRef","selectedSearchResultPosition","setSelectedSearchResultPosition","_getQueryParam","URLSearchParams","onSearch","filter","language","isPersistable","current","slice","length","clearHistory","selectSearchResultAt","position","window","scrollTo","top","offsetTop","behavior","getLanguage","trim","sessionStorage","setItem","query","encodeURIComponent","startTime","Date","now","resultsWithSnippets","onStreamEvent","event","type","message","messages","join","map","result","pre","text","post","snippet","updatedText","streamQueryConfig","apiKey","customerId","corpusKey","offset","metadataFilter","lexicalInterpolation","split","numWords","lambdaLong","lambdaShort","reranker","isEnabled","id","diversityBias","rerankerId","toString","contextConfiguration","sentencesBefore","sentencesAfter","startTag","endTag","chat","store","error","console","log","reset","Provider","summaryNumResults","summaryNumSentences","summaryPromptName","fileName","_jsxFileName","lineNumber","columnNumber","_c","useSearchContext","_s2","context","Error","$RefreshReg$"],"sources":["/Users/syedali/POC/Create UI Threadneedle/columbia-threadneedle-demo/src/contexts/SearchContext.tsx"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { createContext, useContext, ReactNode, useState, useEffect, useRef } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\nimport { SearchResult, SummaryLanguage, SearchError, mmrRerankerId, SearchResultWithSnippet } from \"../view/types\";\nimport { useConfigContext } from \"./ConfigurationContext\";\nimport { HistoryItem, addHistoryItem, deleteHistory, retrieveHistory } from \"./history\";\nimport { ApiV2, streamQueryV2 } from \"@vectara/stream-query-client\";\nimport { END_TAG, START_TAG, parseSnippet } from \"../utils/parseSnippet\";\n\ninterface SearchContextType {\n  filterValue: string;\n  setFilterValue: (source: string) => void;\n  searchValue: string;\n  setSearchValue: (value: string) => void;\n  onSearch: ({\n    value,\n    filter,\n    language,\n    isPersistable\n  }: {\n    value?: string;\n    filter?: string;\n    language?: SummaryLanguage;\n    isPersistable?: boolean;\n  }) => void;\n  reset: () => void;\n  isSearching: boolean;\n  searchError: SearchError | undefined;\n  searchResults: SearchResultWithSnippet[] | undefined;\n  searchTime: number;\n  isSummarizing: boolean;\n  summarizationError: SearchError | undefined;\n  summarizationResponse: string | undefined;\n  summaryTime: number;\n  language: SummaryLanguage;\n  summaryNumResults: number;\n  summaryNumSentences: number;\n  summaryPromptName: string;\n  history: HistoryItem[];\n  clearHistory: () => void;\n  searchResultsRef: React.MutableRefObject<HTMLElement[] | null[]>;\n  selectedSearchResultPosition: number | undefined;\n  selectSearchResultAt: (position: number) => void;\n}\n\nconst SearchContext = createContext<SearchContextType | undefined>(undefined);\n\nconst getQueryParam = (urlParams: URLSearchParams, key: string) => {\n  const value = urlParams.get(key);\n  if (value) return decodeURIComponent(value);\n  return undefined;\n};\n\ntype Props = {\n  children: ReactNode;\n};\n\nexport const SearchContextProvider = ({ children }: Props) => {\n  const { search, rerank, hybrid } = useConfigContext();\n\n  const [searchValue, setSearchValue] = useState<string>(\"\");\n  const [filterValue, setFilterValue] = useState(\"\");\n\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Language\n  const [languageValue, setLanguageValue] = useState<SummaryLanguage>();\n\n  // History\n  const [history, setHistory] = useState<HistoryItem[]>([]);\n\n  // Basic search\n  const [isSearching, setIsSearching] = useState(false);\n  const [searchError, setSearchError] = useState<SearchError | undefined>();\n  const [searchResults, setSearchResults] = useState<SearchResultWithSnippet[] | undefined>(undefined);\n  const [searchTime, setSearchTime] = useState<number>(0);\n\n  // Summarization\n  const [isSummarizing, setIsSummarizing] = useState(false);\n  const [summarizationError, setSummarizationError] = useState<SearchError | undefined>();\n  const [summarizationResponse, setSummarizationResponse] = useState<string>();\n  const [summaryTime, setSummaryTime] = useState<number>(0);\n\n  // Citation selection\n  const searchResultsRef = useRef<HTMLElement[] | null[]>([]);\n  const [selectedSearchResultPosition, setSelectedSearchResultPosition] = useState<number>();\n\n  useEffect(() => {\n    setHistory(retrieveHistory());\n  }, []);\n\n  // Use the browser back and forward buttons to traverse history\n  // of searches, and bookmark or share the URL.\n  useEffect(() => {\n    // Search params are updated as part of calling onSearch, so we don't\n    // want to trigger another search when the search params change if that\n    // search is already in progress.\n    if (isSearching) return;\n\n    const urlParams = new URLSearchParams(searchParams);\n\n    onSearch({\n      // Set to an empty string to wipe out any existing search value.\n      value: getQueryParam(urlParams, \"query\") ?? \"\",\n      filter: getQueryParam(urlParams, \"filter\"),\n      language: getQueryParam(urlParams, \"language\") as SummaryLanguage | undefined,\n      isPersistable: false\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [searchParams]); // TODO: Add onSearch and fix infinite render loop\n\n  useEffect(() => {\n    if (searchResults) {\n      searchResultsRef.current = searchResultsRef.current.slice(0, searchResults.length);\n    } else {\n      searchResultsRef.current = [];\n    }\n  }, [searchResults]);\n\n  const clearHistory = () => {\n    setHistory([]);\n    deleteHistory();\n  };\n\n  const selectSearchResultAt = (position: number) => {\n    if (!searchResultsRef.current[position] || selectedSearchResultPosition === position) {\n      // Reset selected position.\n      setSelectedSearchResultPosition(undefined);\n    } else {\n      setSelectedSearchResultPosition(position);\n      // Scroll to the selected search result.\n      window.scrollTo({\n        top: searchResultsRef.current[position]!.offsetTop - 78,\n        behavior: \"smooth\"\n      });\n    }\n  };\n\n  const getLanguage = (): SummaryLanguage => (languageValue ?? \"auto\") as SummaryLanguage;\n\n  const onSearch = async ({\n    value = searchValue,\n    filter = filterValue,\n    language = getLanguage(),\n    isPersistable = true\n  }: {\n    value?: string;\n    filter?: string;\n    language?: SummaryLanguage;\n    isPersistable?: boolean;\n  }) => {\n    setSearchValue(value);\n    setFilterValue(filter);\n    setLanguageValue(language);\n    setSearchError(undefined);\n    setSummarizationError(undefined);\n    setSummarizationResponse(undefined);\n\n    if (value?.trim()) {\n      // Store current search query in sessionStorage for hallucination evaluation\n      sessionStorage.setItem('lastQuery', value);\n\n      // Save to history.\n      setHistory(addHistoryItem({ query: value, filter, language }, history));\n\n      // Persist to URL, only if the search executes. This way the prior\n      // search that was persisted remains in the URL if the search doesn't execute.\n      if (isPersistable) {\n        setSearchParams(\n          new URLSearchParams(\n            `?query=${encodeURIComponent(value)}&filter=${encodeURIComponent(filter)}&language=${encodeURIComponent(\n              language\n            )}`\n          )\n        );\n      }\n\n      setIsSearching(true);\n      setIsSummarizing(true);\n      setSelectedSearchResultPosition(undefined);\n\n      const startTime = Date.now();\n      let resultsWithSnippets;\n\n      try {\n        const onStreamEvent = (event: ApiV2.StreamEvent) => {\n          switch (event.type) {\n            case \"requestError\":\n            case \"genericError\":\n            case \"unexpectedError\":\n              setSearchError({\n                message: \"Error sending the query request\"\n              });\n              break;\n\n            case \"error\":\n              setSummarizationError({ message: event.messages.join(\", \") });\n              break;\n\n            case \"searchResults\":\n              setIsSearching(false);\n              setSearchTime(Date.now() - startTime);\n\n              resultsWithSnippets = event.searchResults.map((result: SearchResult) => {\n                const { pre, text, post } = parseSnippet(result.text);\n\n                return {\n                  ...result,\n                  snippet: {\n                    pre,\n                    text,\n                    post\n                  }\n                };\n              });\n\n              setSearchResults(resultsWithSnippets);\n\n              break;\n\n            case \"generationChunk\":\n              setSummarizationResponse(event.updatedText);\n              break;\n\n            case \"generationEnd\":\n              setIsSummarizing(false);\n              break;\n\n            case \"end\":\n              setSummaryTime(Date.now() - startTime);\n              break;\n          }\n        };\n\n        const streamQueryConfig: ApiV2.StreamQueryConfig = {\n          apiKey: search.apiKey!,\n          customerId: search.customerId!,\n          query: value,\n          corpusKey: search.corpusKey!,\n          search: {\n            offset: 0,\n            metadataFilter: \"\",\n            lexicalInterpolation:\n              value.trim().split(\" \").length > hybrid.numWords ? hybrid.lambdaLong : hybrid.lambdaShort,\n            reranker:\n              rerank.isEnabled && rerank.id\n                ? rerank.id === mmrRerankerId\n                  ? {\n                      type: \"mmr\",\n                      diversityBias: 0\n                    }\n                  : {\n                      type: \"customer_reranker\",\n                      // rnk_ prefix needed for conversion from API v1 to v2.\n                      rerankerId: `rnk_${rerank.id.toString()}`\n                    }\n                : undefined,\n            contextConfiguration: {\n              // If sentences/chars context is not displayed properly,\n              // you may need to adjust the CONTEXT_MAX_LENGTH variable\n              // in the components that display reference snippets.\n              sentencesBefore: 2,\n              sentencesAfter: 2,\n              startTag: START_TAG,\n              endTag: END_TAG\n            }\n          },\n          chat: { store: true }\n        };\n\n        streamQueryV2({ streamQueryConfig, onStreamEvent });\n      } catch (error) {\n        console.log(\"Summary error\", error);\n        setIsSummarizing(false);\n        setSummarizationError(error as SearchError);\n        setSummarizationResponse(undefined);\n        return;\n      }\n    } else {\n      // Persist to URL.\n      if (isPersistable) setSearchParams(new URLSearchParams(\"\"));\n\n      setSearchResults(undefined);\n      setSummarizationResponse(undefined);\n      setIsSearching(false);\n      setIsSummarizing(false);\n    }\n  };\n\n  const reset = () => {\n    // Specifically don't reset language because that's more of a\n    // user preference.\n    onSearch({ value: \"\", filter: \"\" });\n  };\n\n  return (\n    <SearchContext.Provider\n      value={{\n        filterValue,\n        setFilterValue,\n        searchValue,\n        setSearchValue,\n        onSearch,\n        reset,\n        isSearching,\n        searchError,\n        searchResults,\n        searchTime,\n        isSummarizing,\n        summarizationError,\n        summarizationResponse,\n        summaryTime,\n        language: getLanguage(),\n        summaryNumResults: 7,\n        summaryNumSentences: 3,\n        summaryPromptName: \"vectara-summary-ext-v1.2.0\",\n        history,\n        clearHistory,\n        searchResultsRef,\n        selectedSearchResultPosition,\n        selectSearchResultAt\n      }}\n    >\n      {children}\n    </SearchContext.Provider>\n  );\n};\n\nexport const useSearchContext = () => {\n  const context = useContext(SearchContext);\n  if (context === undefined) {\n    throw new Error(\"useSearchContext must be used within a SearchContextProvider\");\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}