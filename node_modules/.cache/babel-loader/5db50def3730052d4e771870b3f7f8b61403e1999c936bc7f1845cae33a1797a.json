{"ast":null,"code":"var _jsxFileName = \"/Users/syedali/POC/Create UI Threadneedle/columbia-threadneedle-demo/src/view/results/ResultHallucinationScore.tsx\",\n  _s = $RefreshSig$();\nimport { useState, useEffect } from \"react\";\nimport { VuiBadge, VuiFlexContainer, VuiFlexItem, VuiText, VuiTextColor } from \"../../ui\";\nimport { HfInference } from \"@huggingface/inference\";\nimport { useConfigContext } from \"../../contexts/ConfigurationContext\";\nimport \"./ResultHallucinationScore.scss\"; // We'll create this file next\n\n// Known confidence levels for hallucination scores\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Map a numerical score to a confidence level\nconst getConfidenceLevel = score => {\n  if (score < 0) {\n    return \"unavailable\";\n  }\n  if (score <= 0.33) {\n    return \"low\";\n  }\n  if (score <= 0.66) {\n    return \"medium\";\n  }\n  return \"high\";\n};\n\n// Get color and label for the badge based on confidence level\nconst getBadgeProps = confidenceLevel => {\n  switch (confidenceLevel) {\n    case \"low\":\n      return {\n        color: \"danger\",\n        label: \"High Risk\"\n      };\n    // Inverted for clarity: low consistency = high risk\n    case \"medium\":\n      return {\n        color: \"warning\",\n        label: \"Medium Risk\"\n      };\n    case \"high\":\n      return {\n        color: \"success\",\n        label: \"Low Risk\"\n      };\n    // High consistency = low risk\n    case \"unavailable\":\n    default:\n      return {\n        color: \"neutral\",\n        label: \"Score N/A\"\n      };\n  }\n};\n\n// Simple local scoring function that doesn't require API calls\n// This is a fallback when the API is not available\nconst calculateLocalScore = (query, content) => {\n  // Normalize inputs\n  const normalizedQuery = query.toLowerCase().trim();\n  const normalizedContent = content.toLowerCase().trim();\n\n  // Check if query terms appear in the content\n  const queryTerms = normalizedQuery.split(/\\s+/).filter(term => term.length > 3); // Only consider significant terms\n  if (queryTerms.length === 0) return 0.5; // Neutral score for very short queries\n\n  let matchCount = 0;\n  queryTerms.forEach(term => {\n    if (normalizedContent.includes(term)) {\n      matchCount++;\n    }\n  });\n\n  // Calculate score based on term matches (simplified version of what the API might do)\n  const score = Math.min(1, Math.max(0, matchCount / queryTerms.length));\n  return Math.round(score * 100) / 100;\n};\nexport const ResultHallucinationScore = ({\n  result\n}) => {\n  _s();\n  const {\n    search\n  } = useConfigContext();\n  const [hallucinationScore, setHallucinationScore] = useState(-1);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isApiAvailable, setIsApiAvailable] = useState(true);\n  useEffect(() => {\n    const evaluateHallucination = async () => {\n      console.log(\"Evaluating hallucination for result:\", result.document_id);\n\n      // Get the query from sessionStorage if available\n      const searchQuery = sessionStorage.getItem('lastQuery') || \"search query\";\n      console.log(\"Using search query for evaluation:\", searchQuery);\n\n      // Combine the result text\n      const {\n        snippet\n      } = result;\n      const contentText = `${snippet.pre} ${snippet.text} ${snippet.post}`;\n\n      // Try API-based scoring if token is available and API hasn't failed\n      if (search.hfToken && isApiAvailable) {\n        setIsLoading(true);\n        try {\n          // Using the specific format required by HHEM\n          const prompt = `<pad> Determine if the hypothesis is true given the premise?\\n\\nPremise: ${contentText}\\n\\nHypothesis: ${searchQuery}`;\n          console.log(\"Creating HF inference with token\", search.hfToken.substring(0, 5) + \"...\");\n          const inference = new HfInference(search.hfToken);\n          const API_URL = \"https://api-inference.huggingface.co/models/vectara/hallucination_evaluation_model\";\n          const hem = inference.endpoint(API_URL);\n          console.log(\"Sending request to Hugging Face HHEM\");\n          const responseData = await hem.textClassification({\n            inputs: prompt\n          });\n          console.log(\"HHEM response:\", responseData);\n\n          // Process the response\n          let score = -1;\n          if (Array.isArray(responseData)) {\n            for (const labelData of responseData) {\n              if (labelData.label === \"consistent\") {\n                score = Math.round(labelData.score * 100) / 100; // Round to 2 decimal places\n                break;\n              }\n            }\n            // If we didn't find \"consistent\", use the second score (usually that's it)\n            if (score === -1 && responseData.length > 1) {\n              score = Math.round(responseData[1].score * 100) / 100;\n            }\n          } else if (responseData && typeof responseData.score === 'number') {\n            // Handle case where the response might be a direct score\n            score = Math.round(responseData.score * 100) / 100;\n          }\n          console.log(\"API-based hallucination score:\", score);\n          setHallucinationScore(score);\n        } catch (error) {\n          console.error(\"Error evaluating hallucination with API:\", error);\n          setIsApiAvailable(false); // Disable API for future evaluations in this session\n\n          // Fall back to local scoring\n          const localScore = calculateLocalScore(searchQuery, contentText);\n          console.log(\"Fallback to local scoring:\", localScore);\n          setHallucinationScore(localScore);\n        } finally {\n          setIsLoading(false);\n        }\n      } else {\n        // Use local scoring when API is not available\n        const localScore = calculateLocalScore(searchQuery, contentText);\n        console.log(\"Using local scoring:\", localScore);\n        setHallucinationScore(localScore);\n        setIsLoading(false);\n      }\n    };\n    evaluateHallucination();\n  }, [result, search.hfToken, isApiAvailable]);\n  const confidenceLevel = getConfidenceLevel(hallucinationScore);\n  const {\n    color,\n    label\n  } = getBadgeProps(confidenceLevel);\n  return /*#__PURE__*/_jsxDEV(VuiFlexContainer, {\n    alignItems: \"center\",\n    spacing: \"xs\",\n    className: \"hallucinationScoreContainer\",\n    children: [/*#__PURE__*/_jsxDEV(VuiFlexItem, {\n      grow: false,\n      shrink: false,\n      children: /*#__PURE__*/_jsxDEV(VuiBadge, {\n        color: color,\n        className: \"hallucinationBadge\",\n        children: isLoading ? \"Evaluating...\" : label\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 152,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 151,\n      columnNumber: 7\n    }, this), hallucinationScore >= 0 && !isLoading && /*#__PURE__*/_jsxDEV(VuiFlexItem, {\n      grow: false,\n      shrink: false,\n      children: /*#__PURE__*/_jsxDEV(VuiText, {\n        size: \"xs\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: /*#__PURE__*/_jsxDEV(VuiTextColor, {\n            color: \"subdued\",\n            className: \"scoreText\",\n            children: /*#__PURE__*/_jsxDEV(\"strong\", {\n              children: [\"FCS: \", hallucinationScore.toFixed(2), !isApiAvailable && \" (local)\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 161,\n              columnNumber: 17\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 160,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 159,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 158,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 150,\n    columnNumber: 5\n  }, this);\n};\n_s(ResultHallucinationScore, \"yJ9+bgjr5BICLQt1XNdyiEHCLW0=\", false, function () {\n  return [useConfigContext];\n});\n_c = ResultHallucinationScore;\nvar _c;\n$RefreshReg$(_c, \"ResultHallucinationScore\");","map":{"version":3,"names":["useState","useEffect","VuiBadge","VuiFlexContainer","VuiFlexItem","VuiText","VuiTextColor","HfInference","useConfigContext","jsxDEV","_jsxDEV","getConfidenceLevel","score","getBadgeProps","confidenceLevel","color","label","calculateLocalScore","query","content","normalizedQuery","toLowerCase","trim","normalizedContent","queryTerms","split","filter","term","length","matchCount","forEach","includes","Math","min","max","round","ResultHallucinationScore","result","_s","search","hallucinationScore","setHallucinationScore","isLoading","setIsLoading","isApiAvailable","setIsApiAvailable","evaluateHallucination","console","log","document_id","searchQuery","sessionStorage","getItem","snippet","contentText","pre","text","post","hfToken","prompt","substring","inference","API_URL","hem","endpoint","responseData","textClassification","inputs","Array","isArray","labelData","error","localScore","alignItems","spacing","className","children","grow","shrink","fileName","_jsxFileName","lineNumber","columnNumber","size","toFixed","_c","$RefreshReg$"],"sources":["/Users/syedali/POC/Create UI Threadneedle/columbia-threadneedle-demo/src/view/results/ResultHallucinationScore.tsx"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { VuiBadge, VuiFlexContainer, VuiFlexItem, VuiText, VuiTextColor } from \"../../ui\";\nimport { SearchResultWithSnippet } from \"../types\";\nimport { HfInference } from \"@huggingface/inference\";\nimport { useConfigContext } from \"../../contexts/ConfigurationContext\";\nimport \"./ResultHallucinationScore.scss\"; // We'll create this file next\n\n// Known confidence levels for hallucination scores\nexport type ConfidenceLevel = \"unavailable\" | \"low\" | \"medium\" | \"high\";\n\n// Map a numerical score to a confidence level\nconst getConfidenceLevel = (score: number): ConfidenceLevel => {\n  if (score < 0) {\n    return \"unavailable\";\n  }\n  if (score <= 0.33) {\n    return \"low\";\n  }\n  if (score <= 0.66) {\n    return \"medium\";\n  }\n  return \"high\";\n};\n\n// Get color and label for the badge based on confidence level\nconst getBadgeProps = (\n  confidenceLevel: ConfidenceLevel\n): { color: \"success\" | \"warning\" | \"danger\" | \"neutral\"; label: string } => {\n  switch (confidenceLevel) {\n    case \"low\":\n      return { color: \"danger\", label: \"High Risk\" }; // Inverted for clarity: low consistency = high risk\n    case \"medium\":\n      return { color: \"warning\", label: \"Medium Risk\" };\n    case \"high\":\n      return { color: \"success\", label: \"Low Risk\" }; // High consistency = low risk\n    case \"unavailable\":\n    default:\n      return { color: \"neutral\", label: \"Score N/A\" };\n  }\n};\n\n// Simple local scoring function that doesn't require API calls\n// This is a fallback when the API is not available\nconst calculateLocalScore = (query: string, content: string): number => {\n  // Normalize inputs\n  const normalizedQuery = query.toLowerCase().trim();\n  const normalizedContent = content.toLowerCase().trim();\n  \n  // Check if query terms appear in the content\n  const queryTerms = normalizedQuery.split(/\\s+/).filter(term => term.length > 3); // Only consider significant terms\n  if (queryTerms.length === 0) return 0.5; // Neutral score for very short queries\n  \n  let matchCount = 0;\n  queryTerms.forEach(term => {\n    if (normalizedContent.includes(term)) {\n      matchCount++;\n    }\n  });\n  \n  // Calculate score based on term matches (simplified version of what the API might do)\n  const score = Math.min(1, Math.max(0, matchCount / queryTerms.length));\n  return Math.round(score * 100) / 100;\n};\n\ninterface ResultHallucinationScoreProps {\n  result: SearchResultWithSnippet;\n}\n\nexport const ResultHallucinationScore = ({ result }: ResultHallucinationScoreProps) => {\n  const { search } = useConfigContext();\n  const [hallucinationScore, setHallucinationScore] = useState<number>(-1);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [isApiAvailable, setIsApiAvailable] = useState<boolean>(true);\n\n  useEffect(() => {\n    const evaluateHallucination = async () => {\n      console.log(\"Evaluating hallucination for result:\", result.document_id);\n      \n      // Get the query from sessionStorage if available\n      const searchQuery = sessionStorage.getItem('lastQuery') || \"search query\";\n      console.log(\"Using search query for evaluation:\", searchQuery);\n      \n      // Combine the result text\n      const { snippet } = result;\n      const contentText = `${snippet.pre} ${snippet.text} ${snippet.post}`;\n      \n      // Try API-based scoring if token is available and API hasn't failed\n      if (search.hfToken && isApiAvailable) {\n        setIsLoading(true);\n        try {\n          // Using the specific format required by HHEM\n          const prompt = `<pad> Determine if the hypothesis is true given the premise?\\n\\nPremise: ${contentText}\\n\\nHypothesis: ${searchQuery}`;\n          \n          console.log(\"Creating HF inference with token\", search.hfToken.substring(0, 5) + \"...\");\n          const inference = new HfInference(search.hfToken);\n          const API_URL = \"https://api-inference.huggingface.co/models/vectara/hallucination_evaluation_model\";\n          const hem = inference.endpoint(API_URL);\n          \n          console.log(\"Sending request to Hugging Face HHEM\");\n          const responseData = await hem.textClassification({ inputs: prompt });\n          console.log(\"HHEM response:\", responseData);\n          \n          // Process the response\n          let score = -1;\n          if (Array.isArray(responseData)) {\n            for (const labelData of responseData) {\n              if (labelData.label === \"consistent\") {\n                score = Math.round(labelData.score * 100) / 100; // Round to 2 decimal places\n                break;\n              }\n            }\n            // If we didn't find \"consistent\", use the second score (usually that's it)\n            if (score === -1 && responseData.length > 1) {\n              score = Math.round((responseData[1] as any).score * 100) / 100;\n            }\n          } else if (responseData && typeof (responseData as any).score === 'number') {\n            // Handle case where the response might be a direct score\n            score = Math.round((responseData as any).score * 100) / 100;\n          }\n          \n          console.log(\"API-based hallucination score:\", score);\n          setHallucinationScore(score);\n        } catch (error) {\n          console.error(\"Error evaluating hallucination with API:\", error);\n          setIsApiAvailable(false); // Disable API for future evaluations in this session\n          \n          // Fall back to local scoring\n          const localScore = calculateLocalScore(searchQuery, contentText);\n          console.log(\"Fallback to local scoring:\", localScore);\n          setHallucinationScore(localScore);\n        } finally {\n          setIsLoading(false);\n        }\n      } else {\n        // Use local scoring when API is not available\n        const localScore = calculateLocalScore(searchQuery, contentText);\n        console.log(\"Using local scoring:\", localScore);\n        setHallucinationScore(localScore);\n        setIsLoading(false);\n      }\n    };\n\n    evaluateHallucination();\n  }, [result, search.hfToken, isApiAvailable]);\n\n  const confidenceLevel = getConfidenceLevel(hallucinationScore);\n  const { color, label } = getBadgeProps(confidenceLevel);\n\n  return (\n    <VuiFlexContainer alignItems=\"center\" spacing=\"xs\" className=\"hallucinationScoreContainer\">\n      <VuiFlexItem grow={false} shrink={false}>\n        <VuiBadge color={color} className=\"hallucinationBadge\">\n          {isLoading ? \"Evaluating...\" : label}\n        </VuiBadge>\n      </VuiFlexItem>\n      {hallucinationScore >= 0 && !isLoading && (\n        <VuiFlexItem grow={false} shrink={false}>\n          <VuiText size=\"xs\">\n            <p>\n              <VuiTextColor color=\"subdued\" className=\"scoreText\">\n                <strong>FCS: {hallucinationScore.toFixed(2)}{!isApiAvailable && \" (local)\"}</strong>\n              </VuiTextColor>\n            </p>\n          </VuiText>\n        </VuiFlexItem>\n      )}\n    </VuiFlexContainer>\n  );\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}